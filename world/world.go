package world

import (
	"log"
	"unsafe"

	"github.com/benanders/mineral/render"

	"github.com/go-gl/gl/v3.3-core/gl"
)

const (
	// The size of a chunk, measured in blocks.
	ChunkWidth  = 16
	ChunkHeight = 256
	ChunkDepth  = 16

	// MaxRenderRadius is the maximum value for the render radius of chunks. It
	// is the maximum distance a player could see ahead of them (measured in
	// chunks).
	MaxRenderRadius = 32
)

// World stores all the loaded chunks and loads/unloads chunks as required.
type World struct {
	RenderRadius uint               // Current render distance
	chunks       []Chunk            // All loaded chunks
	channels     []chan interface{} // Channels to goroutines loading chunks

	program    uint32
	mvpUnf     int32
	posAttr    uint32
	normalAttr uint32
	uvAttr     uint32
}

const (
	// ChunkVertexShader stores the source code for the vertex shader for the
	// chunk rendering.
	chunkVertexShader = `
#version 330

uniform mat4 mvp;

in vec3 position;
in vec3 normal;
in vec2 uv;

out vec2 fragUV;

void main() {
	gl_Position = mvp * vec4(position, 1.0);
	fragUV = uv;
}	
`

	// ChunkFragmentShader stores the source code for the fragment shader for
	// the chunk rendering.
	chunkFragmentShader = `
#version 330

in vec2 fragUV;
out vec4 color;

void main() {
	color = vec4(fragUV, 0.0, 1.0);
}	
`
)

// NewWorld creates a new world instance with no loaded chunks yet.
func New(renderRadius uint) *World {
	// Create the chunk rendering program
	program, err := render.LoadShaders(chunkVertexShader, chunkFragmentShader)
	if err != nil {
		log.Fatalln(err)
	}
	gl.UseProgram(program)

	// Cache the uniform locations
	mvpUnf := gl.GetUniformLocation(program, gl.Str("mvp\x00"))

	// Cache the attribute locations
	posAttr := uint32(gl.GetAttribLocation(program, gl.Str("position\x00")))
	normalAttr := uint32(gl.GetAttribLocation(program, gl.Str("normal\x00")))
	uvAttr := uint32(gl.GetAttribLocation(program, gl.Str("uv\x00")))

	return &World{renderRadius, make([]Chunk, 0), make([]chan interface{}, 0),
		program, mvpUnf, posAttr, normalAttr, uvAttr}
}

// Destroy unloads all the currently loaded chunks.
func (w *World) Destroy() {
	gl.DeleteProgram(w.program)

	// Destroy all loaded chunks
	for _, chunk := range w.chunks {
		chunk.Destroy()
	}
	w.chunks = nil

	// Close all pending channels
	for _, ch := range w.channels {
		close(ch)
	}
}

// VertexLoadResult stores the data generated when a chunk's vertex data is
// reloaded from its existing block data.
type vertexLoadResult struct {
	p, q     int
	vertices []float32
}

// ReloadChunk queues the chunk at the given coordinates for a vertex data
// reload. If the chunk isn't yet loaded, then does nothing (doesn't load it).
func (w *World) reloadChunk(p, q int) {
	// Find the chunk
	chunk := w.findChunk(p, q)
	if chunk == nil || chunk.blocks == nil {
		return // Chunk isn't loaded
	}

	// Copy block data into a new array, in case the chunk is unloaded while
	// we're in the middle of loading it
	blocks := make([]blockType, len(chunk.blocks))
	copy(blocks, chunk.blocks)

	// Load the vertex data on
	ch := make(chan interface{})
	w.channels = append(w.channels, ch)
	go (func() {
		vertices := genVertices(p, q, blocks)
		ch <- vertexLoadResult{p, q, vertices}
	})()
}

// CompleteLoadResult stores the data generated when a chunk's block, vertex,
// and lighting data is all loaded at once.
type completeLoadResult struct {
	p, q     int
	blocks   blockData
	vertices []float32
}

// LoadChunk queues the chunk at the given coordinates for loading. If the
// chunk is already loaded, then does nothing (doesn't reload its data).
func (w *World) LoadChunk(p, q int) {
	// Check the chunk isn't already loaded
	if chunk := w.findChunk(p, q); chunk != nil {
		return
	}

	// Load the chunk's block and vertex data
	ch := make(chan interface{})
	w.channels = append(w.channels, ch)
	go (func() {
		blocks := genBlocks(p, q)
		vertices := genVertices(p, q, blocks)
		ch <- completeLoadResult{p, q, blocks, vertices}
	})()
}

// Update should be called every update tick to check for completed load tasks.
func (w *World) Update() {
	// Select across all chunk loading channels
	for _, ch := range w.channels {
		select {
		case result := <-ch:
			w.handleFinishedTask(result)
		default:
			// We want non-blocking channel reads
		}
	}
}

// HandleFinishedTask takes the data generated by a chunk loading task and
// updates the relevant chunk with the information.
func (w *World) handleFinishedTask(result interface{}) {
	switch r := result.(type) {
	case completeLoadResult:
		// Loaded all information to do with a chunk
		chunk := newChunk(r.p, r.q)
		chunk.blocks = r.blocks
		w.uploadChunk(&chunk, r.vertices)
		w.chunks = append(w.chunks, chunk)

	case vertexLoadResult:
		// Reloaded a chunk's vertex data
		chunk := w.findChunk(r.p, r.q)
		if chunk == nil {
			return // Chunk was unloaded while we were loading its data
		}
		w.uploadChunk(chunk, r.vertices)
	}
}

// UploadChunk pushes the new vertex data for a chunk onto the GPU.
func (w *World) uploadChunk(chunk *Chunk, vertices []float32) {
	chunk.numVertices = int32(len(vertices)) / valuesPerVertex

	// Upload the vertex data by deleting the current vertex buffer and
	// reallocating it
	gl.BindVertexArray(chunk.vao)
	gl.DeleteBuffers(1, &chunk.vbo)
	gl.GenBuffers(1, &chunk.vbo)
	gl.BindBuffer(gl.ARRAY_BUFFER, chunk.vbo)
	gl.BufferData(gl.ARRAY_BUFFER,
		int(unsafe.Sizeof(float32(0.0)))*len(vertices),
		gl.Ptr(vertices),
		gl.STATIC_DRAW)

	// Set the vertex attributes on the new buffer
	gl.UseProgram(w.program)

	// Position attribute
	gl.EnableVertexAttribArray(w.posAttr)
	gl.VertexAttribPointer(w.posAttr, 3, gl.FLOAT, false,
		valuesPerVertex*int32(unsafe.Sizeof(float32(0.0))), nil)

	// Normal attribute
	gl.EnableVertexAttribArray(w.normalAttr)
	gl.VertexAttribPointer(w.normalAttr, 3, gl.FLOAT, false,
		valuesPerVertex*int32(unsafe.Sizeof(float32(0.0))),
		gl.PtrOffset(3*int(unsafe.Sizeof(float32(0.0)))))

	// UV attribute
	gl.EnableVertexAttribArray(w.uvAttr)
	gl.VertexAttribPointer(w.uvAttr, 3, gl.FLOAT, false,
		valuesPerVertex*int32(unsafe.Sizeof(float32(0.0))),
		gl.PtrOffset(6*int(unsafe.Sizeof(float32(0.0)))))
}

// RenderInfo stores information required by the world for rendering.
type RenderInfo struct {
	Camera *render.Camera
}

// Render draws all loaded chunks with vertex data to the screen.
func (w *World) Render(info RenderInfo) {
	// Enable some OpenGL state
	gl.Enable(gl.CULL_FACE)
	gl.Enable(gl.DEPTH_TEST)

	// Use the chunk shader program
	gl.UseProgram(w.program)

	// Set the MVP uniform on the shader
	gl.UniformMatrix4fv(w.mvpUnf, 1, false, &info.Camera.View[0])

	// Render each chunk
	for _, chunk := range w.chunks {
		chunk.render(info)
	}

	// Reset the OpenGL state
	gl.Disable(gl.CULL_FACE)
	gl.Disable(gl.DEPTH_TEST)
}

// FindChunk checks to see if the chunk at the given coordinates is already
// loaded, and if so returns a pointer to it. Otherwise, returns nil.
func (w *World) findChunk(p, q int) *Chunk {
	for _, chunk := range w.chunks {
		if chunk.p == p && chunk.q == q {
			return &chunk
		}
	}
	return nil
}

// Chunk stores information associated with a chunk, including OpenGL rendering
// information, block data, vertex data, and lighting data.
type Chunk struct {
	p, q        int       // The position of the chunk, in chunk coordinates
	blocks      blockData // The cached block data for the chunk
	numVertices int32     // The number of vertices to render
	vao, vbo    uint32    // OpenGL buffers
}

// NewChunk creates a new, empty chunk with no block, rendering, or lighting
// data.
func newChunk(p, q int) Chunk {
	// Create a VAO and VBO, but don't upload any data
	var vao, vbo uint32
	gl.GenVertexArrays(1, &vao)
	gl.BindVertexArray(vao)
	gl.GenBuffers(1, &vbo)
	gl.BindBuffer(gl.ARRAY_BUFFER, vbo)
	return Chunk{p: p, q: q, vao: vao, vbo: vbo}
}

// Destroy releases all resources allocated when creating a chunk.
func (c *Chunk) Destroy() {
	gl.DeleteBuffers(1, &c.vbo)
	gl.DeleteVertexArrays(1, &c.vao)
}

// Render the chunk to the screen.
func (c *Chunk) render(info RenderInfo) {
	// Don't bother rendering an unloaded chunk
	if c.blocks == nil {
		return
	}

	// Render the chunk
	gl.BindVertexArray(c.vao)
	gl.DrawArrays(gl.TRIANGLES, 0, c.numVertices)
}
